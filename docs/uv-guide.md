# A Guide to Python Package Management with `uv`

`uv` is a fast Python package installer and resolver, designed to be a drop-in replacement for `pip` and `pip-tools`. It aims to provide a more efficient and reliable experience for managing Python dependencies.

This guide will walk you through common `uv` workflows: upgrading packages, locking dependencies, creating `requirements.txt` files, and resolving conflicts.
---

## 1. Adding Packages

Packages can be added to the `pyproject.toml` file using `uv add`.

```bash
# Add a single package
uv add requests # Will install the latest compatible versions of requests

# Add a single package at a specified version
uv add requests~=2.250 # Will install the latest compatible versions of requests at 2.25.*

# Add multiple packages
uv add beautifulsoup4 lxml # Will install the latest compatible versions of both beautifulsoup4 and lxml
```

---

## 2. Upgrading Packages

Navigate to the `pyproject.toml` file, locate the image group, and update the version to your desired one. Afterward, execute `uv lock` to prevent any dependency conflicts.

## 5. Locking Dependencies (`uv pip compile`)

Locking dependencies means creating a precise list of *all* direct and transitive dependencies, including their exact versions, that your project needs. This ensures reproducible builds across different environments. `uv` uses `uv pip compile` for this, similar to `pip-compile` from `pip-tools`.

### Creating an `in.txt` File

Start by listing your direct dependencies in a file, typically named `requirements.in` or `pyproject.toml` (if using `uv` with `pyproject.toml`). For simplicity, let's use `requirements.in`.

**`requirements.in` example:**
```
requests
beautifulsoup4
```

### Compiling and Locking

Now, use `uv pip compile` to generate a locked `requirements.txt` file. This file will contain all direct and transitive dependencies with their exact versions.

```bash
# Generate requirements.txt from requirements.in
uv pip compile requirements.in -o requirements.txt
```

After running this, `requirements.txt` might look something like this (versions will vary):

**`requirements.txt` example:**
```
# This file is autogenerated by uv.
# Do not edit this file by hand.
#
#   uv pip compile requirements.in
#
certifi==2024.7.4
charset-normalizer==3.3.2
idna==3.7
requests==2.32.3
beautifulsoup4==4.12.3
soupsieve==2.5
urllib3==2.2.1
```

### Installing from a Locked File

To install exactly the versions specified in your locked file:

```bash
uv install -r requirements.txt
```

This is crucial for deployment and team collaboration, as everyone will be using the exact same dependency versions.

---

## 6. Resolving Conflicts

Dependency conflicts occur when two or more packages require different, incompatible versions of the same dependency. `uv`'s resolver is designed to be fast and provide helpful error messages when conflicts arise.

### How `uv` Handles Conflicts

When you run `uv install`, `uv update`, or `uv pip compile`, `uv` attempts to find a set of package versions that satisfy all requirements. If it cannot, it will report a conflict.

**Example of a potential conflict:**

Imagine `package_A` requires `dependency_X==1.0` and `package_B` requires `dependency_X>=2.0`.

If you try to install both:

```
# requirements.in
package_A
package_B
```bash
uv pip compile requirements.in -o requirements.txt
```

`uv` would output an error similar to this (simplified):

```
error: Failed to resolve dependencies:
  - package_A requires dependency_X==1.0
  - package_B requires dependency_X>=2.0
  The requested versions of dependency_X (1.0 and >=2.0) are incompatible.
```

### Strategies for Resolving Conflicts

1.  **Review Error Messages:** `uv`'s error messages are usually very informative, pointing out exactly which packages are in conflict and what their version requirements are. Read them carefully.

2.  **Adjust Direct Dependencies:**
    * **Pinning Versions:** If you know a specific version of a package works, you can explicitly pin it in your `requirements.in` file:
        ```
        requests==2.32.3
        beautifulsoup4>=4.10,<4.13
        ```
        This gives `uv` a narrower range to work with.
    * **Loosen/Tighten Constraints:** Sometimes, you might have overly strict constraints. Consider if you can loosen a constraint (e.g., `package_A>=1.0` instead of `package_A==1.0`). Conversely, if a package is pulling in an old dependency, you might need to tighten its constraint to force a newer version.

3.  **Find Compatible Versions:**
    * Check the documentation or release notes of the conflicting packages. They might mention known incompatibilities or recommended versions of their dependencies.
    * Use `uv`'s `uv pip list` (after a partial install or in a separate environment) to see what versions are currently installed and their direct dependencies.

4.  **Exclude Problematic Packages (Temporarily):**
    If you're debugging a complex conflict, you might temporarily remove one of the conflicting direct dependencies from `requirements.in` to see if the other packages can resolve. This helps isolate the source of the conflict.

5.  **Use `uv pip install --dry-run` or `uv pip compile --dry-run`:**
    These commands will show you what `uv` *would* do without actually making changes, which can be helpful for understanding the resolution process.

6.  **Upgrade/Downgrade Conflicting Packages:**
    Sometimes, simply upgrading one of the conflicting direct dependencies to a newer version (that has updated its own dependency requirements) can resolve the issue. In other cases, you might need to downgrade a package if a newer version introduced an incompatibility.

    ```bash
    # Try upgrading a specific package
    uv update package_A
    ```

7.  **Isolate and Test:**
    For very complex dependency graphs, it can be helpful to create a new, minimal `requirements.in` file with only the conflicting packages to reproduce the issue and test solutions in isolation.

---

## 7. Creating `requirements.txt` (Recap)

As demonstrated in the "Locking Dependencies" section, the primary way to create a `requirements.txt` file with `uv` is by compiling an `in` file:

1.  Create a `requirements.in` file listing your top-level dependencies.
2.  Run `uv pip compile requirements.in -o requirements.txt`.

This process ensures that `requirements.txt` contains a complete, reproducible set of all your project's dependencies.

---

## Conclusion

`uv` offers a powerful and fast way to manage Python packages. By understanding how to use `uv update` for upgrades, `uv pip compile` for locking dependencies, and the strategies for resolving conflicts, you can maintain a robust and reproducible development environment for your Python projects.
